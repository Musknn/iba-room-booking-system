-- ============================================
-- USER TABLE (MASTER TABLE - ALL USERS)
-- ============================================
CREATE TABLE User_Table (
    ERP              NUMBER(5) PRIMARY KEY,
    name             VARCHAR2(100) NOT NULL,
    email            VARCHAR2(150) UNIQUE NOT NULL,
    user_password    VARCHAR2(16) NOT NULL, -- Simple password (8-16 chars)
    role             VARCHAR2(20) NOT NULL,
    phone_number     VARCHAR2(11) NOT NULL,
    verification_code VARCHAR2(10),
    code_expiry      TIMESTAMP,
    
    -- Constraints
    CONSTRAINT chk_email_domain CHECK (
        email LIKE '%@iba.edu.pk' OR email LIKE '%@khi.iba.edu.pk'
    ),
    CONSTRAINT chk_password_length CHECK (
        LENGTH(user_password) >= 8 AND LENGTH(user_password) <= 16
    ),
    CONSTRAINT chk_valid_role CHECK (role IN ('Student', 'BuildingIncharge', 'ProgramOffice')),
    CONSTRAINT chk_phone_format CHECK (
        REGEXP_LIKE(phone_number, '^03[0-9]{9}$')
    )
);
/*
Purpose: Stores all system users with their authentication details
Note: 
- Email must be from IBA domain
- Password must be 8-16 characters
- Phone must be Pakistani format (03XXXXXXXXX)
*/

-- ============================================
-- PENDING REGISTRATION TABLE
-- ============================================
CREATE TABLE PendingRegistration (
    email            VARCHAR2(150) PRIMARY KEY,
    erp              NUMBER(5) NOT NULL UNIQUE,
    name             VARCHAR2(100) NOT NULL,
    user_password    VARCHAR2(16) NOT NULL,
    phone_number     VARCHAR2(11) NOT NULL,
    role             VARCHAR2(20) NOT NULL,
    verification_code VARCHAR2(10),
    code_expiry      TIMESTAMP NOT NULL,
    
    -- Constraints
    CONSTRAINT chk_pending_email CHECK (
        email LIKE '%@iba.edu.pk' OR email LIKE '%@khi.iba.edu.pk'
    ),
    CONSTRAINT chk_pending_role CHECK (role IN ('Student', 'BuildingIncharge', 'ProgramOffice'))
);
/*
Purpose: Temporary storage for users during email verification
Note: Records are moved to User_Table after successful OTP verification
*/

-- ============================================
-- STUDENT TABLE
-- ============================================
CREATE TABLE Student (
    ERP          NUMBER(5) PRIMARY KEY,
    program      VARCHAR2(10) NOT NULL,
    intake_year  NUMBER(4) NOT NULL,
    
    -- Foreign Key with CASCADE
    FOREIGN KEY (ERP) REFERENCES User_Table(ERP) ON DELETE CASCADE,
    
    -- Constraints
    CONSTRAINT chk_valid_program CHECK (program IN (
        'BBA', 'BSACF', 'BSECO', 'BSBA', 'BSSS', 'BSCS', 'BSEM', 'BSMT'
    ))
);
/*
Purpose: Stores student-specific academic information
Note: Each student must have a corresponding record in User_Table
*/

-- ============================================
-- BUILDING TABLE
-- ============================================
CREATE TABLE Building (
    building_id   NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1) PRIMARY KEY,
    building_name VARCHAR2(50) NOT NULL UNIQUE
);
/*
Purpose: Stores building information for room management
Note: Each building can have multiple rooms
*/

-- ============================================
-- INCHARGE TABLE
-- ============================================
CREATE TABLE Incharge (
    incharge_id NUMBER(5) PRIMARY KEY,                     
    building_id NUMBER NOT NULL UNIQUE,
    
    -- Foreign Keys with CASCADE
    FOREIGN KEY (incharge_id) REFERENCES User_Table(ERP) ON DELETE CASCADE,
    FOREIGN KEY (building_id) REFERENCES Building(building_id) ON DELETE CASCADE
);
/*
Purpose: Assigns building incharges (one incharge per building)
Note: Incharge must have role 'BuildingIncharge' in User_Table
*/

-- ============================================
-- ROOM TABLE
-- ============================================
CREATE TABLE Room (
    room_id      NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1) PRIMARY KEY,
    building_id  NUMBER NOT NULL,
    room_name    VARCHAR2(15) NOT NULL,
    room_type    VARCHAR2(20) NOT NULL,
    
    -- Foreign Key
    FOREIGN KEY (building_id) REFERENCES Building(building_id) ON DELETE CASCADE,
    
    -- Constraints
    CONSTRAINT chk_room_type CHECK (room_type IN ('CLASSROOM', 'BREAKOUT')),
    CONSTRAINT uk_room_building UNIQUE (building_id, room_name)
);
/*
Purpose: Stores room details for booking system
Note: 
- Room names must be unique within a building
- Room types: CLASSROOM, BREAKOUT, or LAB
*/

-- ============================================
-- SCHEDULE TABLE (ACADEMIC TIMETABLE)
-- ============================================
CREATE TABLE Schedule (
    schedule_id   NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1) PRIMARY KEY,
    room_id       NUMBER NOT NULL,
    day_of_week   VARCHAR2(10) NOT NULL,
    start_time    TIMESTAMP NOT NULL,
    end_time      TIMESTAMP NOT NULL,
    course_code   VARCHAR2(20) NOT NULL,
    
    -- Foreign Keys
    FOREIGN KEY (room_id) REFERENCES Room(room_id) ON DELETE CASCADE,
    
    -- Constraints
    CONSTRAINT chk_valid_day CHECK (UPPER(day_of_week) IN (
        'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY'
    )),
    CONSTRAINT chk_time_order CHECK (end_time > start_time)
);
/*
Purpose: Academic timetable to prevent booking conflicts during class hours
Note: 
- Only weekdays (Monday to Saturday)
- Prevents booking rooms during scheduled classes
*/

-- ============================================
-- BOOKING TABLE 
-- ============================================
CREATE TABLE Booking (
    booking_id      NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1) PRIMARY KEY,
    ERP             NUMBER(5) NOT NULL,
    room_id         NUMBER NOT NULL,
    booking_date    DATE NOT NULL,
    start_time      TIMESTAMP NOT NULL,
    end_time        TIMESTAMP NOT NULL,
    purpose         VARCHAR2(500) NOT NULL,
    status          VARCHAR2(20) DEFAULT 'Approved',
    created_date    TIMESTAMP DEFAULT SYSTIMESTAMP,
    
    -- Foreign Keys
    FOREIGN KEY (ERP) REFERENCES User_Table(ERP) ON DELETE CASCADE,
    FOREIGN KEY (room_id) REFERENCES Room(room_id) ON DELETE CASCADE,
    
    -- Constraints
    CONSTRAINT chk_booking_status CHECK (status IN ('Approved', 'Rejected', 'Cancelled')),
    CONSTRAINT chk_booking_time_order CHECK (end_time > start_time),
    CONSTRAINT chk_booking_duration CHECK (
        (end_time - start_time) <= INTERVAL '1' HOUR + INTERVAL '15' MINUTE
    ),
    CONSTRAINT uk_booking_time UNIQUE (room_id, booking_date, start_time, status) 
);

-- Create trigger for future date validation
CREATE OR REPLACE TRIGGER trg_booking_future_date
BEFORE INSERT OR UPDATE ON Booking
FOR EACH ROW
BEGIN
    IF :NEW.booking_date < TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Booking date cannot be in the past.');
    END IF;
END;
/
/*
Purpose: Manages room reservations with auto-approval and manual rejection/cancellation
Notes:
- Default status: 'Approved' (auto-approved if room available)
- 'Rejected': PO can reject classrooms, BI can reject breakouts
- 'Cancelled': Student can cancel their booking
- Maximum duration: 1 hour 15 minutes
- Unique constraint prevents double booking same room at same time with same status
*/

-- ============================================
-- ANNOUNCEMENT TABLE
-- ============================================
CREATE TABLE Announcement (
    announcement_id NUMBER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1) PRIMARY KEY,
    ERP             NUMBER(5) NOT NULL,
    title           VARCHAR2(100) NOT NULL,
    description     VARCHAR2(300),
    date_posted     TIMESTAMP NOT NULL,
    created_date    TIMESTAMP DEFAULT SYSTIMESTAMP,
    
    -- Foreign Key
    FOREIGN KEY (ERP) REFERENCES User_Table(ERP) ON DELETE CASCADE
);
/*
Purpose: System announcements and notifications
Note: Can be posted by any user (admin/student/incharge)
*/

CREATE OR REPLACE PROCEDURE CheckUserExists(
    p_email       IN User_Table.email%TYPE,
    p_phonenumber IN User_Table.phone_number%TYPE,
    p_user_exists OUT NUMBER,
    p_is_pending  OUT NUMBER,
    p_message     OUT VARCHAR2
)
AS
BEGIN
    /*
    PURPOSE: Check if user exists before registration
    CALLED: Before RegisterStudent
    */
    
    p_user_exists := 0;
    p_is_pending := 0;
    p_message := '';
    
    -- Check if email or phone already in User_Table
    SELECT COUNT(*) INTO p_user_exists
    FROM User_Table
    WHERE (p_email IS NOT NULL AND email = p_email)
       OR (p_phonenumber IS NOT NULL AND phone_number = p_phonenumber);
    
    -- Only check pending if not in User_Table
    IF p_user_exists = 0 THEN
        SELECT COUNT(*) INTO p_is_pending
        FROM PendingRegistration
        WHERE (p_email IS NOT NULL AND email = p_email)
           OR (p_phonenumber IS NOT NULL AND phone_number = p_phonenumber);
    END IF;
    
END CheckUserExists;
/

CREATE OR REPLACE PROCEDURE RegisterStudent(
    p_erp         IN User_Table.ERP%TYPE,
    p_name        IN User_Table.name%TYPE,
    p_email       IN User_Table.email%TYPE,
    p_password    IN User_Table.user_password%TYPE,
    p_phonenumber IN User_Table.phone_number%TYPE,
    p_program     IN Student.program%TYPE,
    p_intake_year IN Student.intake_year%TYPE,
    p_code        OUT VARCHAR2,
    p_success     OUT NUMBER,
    p_message     OUT VARCHAR2
)
AS
    v_erp_exists NUMBER;
    v_email_exists NUMBER;
    v_phone_exists NUMBER;
BEGIN
    /*
    PURPOSE: Start student registration with OTP
    CALLED: After CheckUserExists confirms user doesn't exist
    */
    
    p_success := 0;
    p_message := '';
    
    -- Validate email domain
    IF NOT (p_email LIKE '%@khi.iba.edu.pk') THEN
        p_message := 'Only IBA student emails (@khi.iba.edu.pk) allowed';
        RETURN;
    END IF;
    
    -- Check duplicate ERP
    SELECT COUNT(*) INTO v_erp_exists
    FROM User_Table
    WHERE erp = p_erp;
    
    IF v_erp_exists > 0 THEN
        p_message := 'ERP number already registered';
        RETURN;
    END IF;
    
    -- Check duplicate email
    SELECT COUNT(*) INTO v_email_exists
    FROM User_Table
    WHERE email = p_email;
    
    IF v_email_exists > 0 THEN
        p_message := 'Email already registered';
        RETURN;
    END IF;
    
    -- Check duplicate phone
    SELECT COUNT(*) INTO v_phone_exists
    FROM User_Table
    WHERE phone_number = p_phonenumber;
    
    IF v_phone_exists > 0 THEN
        p_message := 'Phone number already registered';
        RETURN;
    END IF;
    
    -- Generate 6-digit OTP
    p_code := LPAD(TRUNC(DBMS_RANDOM.VALUE(100000, 999999)), 6, '0');
    
    -- Remove old pending registration if exists
    DELETE FROM PendingRegistration
    WHERE email = p_email OR erp = p_erp OR phone_number = p_phonenumber;
    
    -- Insert into pending table
    INSERT INTO PendingRegistration (
        email, erp, name, user_password, phone_number, role,
        verification_code, code_expiry
    ) VALUES (
        p_email, p_erp, p_name, p_password, p_phonenumber, 'Student',
        p_code, SYSTIMESTAMP + INTERVAL '10' MINUTE
    );
    
    COMMIT;
    
    p_success := 1;
    p_message := 'Verification code sent to email';
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        p_success := 0;
        p_message := 'Registration failed: ' || SQLERRM;
END RegisterStudent;
/

CREATE OR REPLACE PROCEDURE ResendVerificationCode(
    p_email     IN PendingRegistration.email%TYPE,
    p_new_code  OUT VARCHAR2,
    p_success   OUT NUMBER,
    p_message   OUT VARCHAR2
)
AS
    v_pending_exists NUMBER;
    v_email_domain VARCHAR2(50);
BEGIN
    /*
    PURPOSE: Resend OTP to email for pending registration
    CALLED: When user doesn't receive OTP email or it expired
    NOTE: Only works with email since OTPs are sent via email
    */
    
    p_success := 0;
    p_new_code := NULL;
    p_message := '';
    
    -- Validate email format
    IF p_email IS NULL OR LENGTH(p_email) < 10 THEN
        p_message := 'Valid email address is required';
        RETURN;
    END IF;
    
    -- Validate it's an IBA email
    v_email_domain := SUBSTR(p_email, INSTR(p_email, '@'));
    IF v_email_domain != '@khi.iba.edu.pk' THEN
        p_message := 'Only IBA student emails (@khi.iba.edu.pk) allowed';
        RETURN;
    END IF;
    
    -- Check if pending registration exists for this email
    SELECT COUNT(*) INTO v_pending_exists
    FROM PendingRegistration
    WHERE email = p_email;
    
    IF v_pending_exists > 0 THEN
        -- Generate new 6-digit OTP
        p_new_code := LPAD(TRUNC(DBMS_RANDOM.VALUE(100000, 999999)), 6, '0');
        
        -- Update with new code and expiry (10 minutes from now)
        UPDATE PendingRegistration
        SET verification_code = p_new_code,
            code_expiry = SYSTIMESTAMP + INTERVAL '10' MINUTE
        WHERE email = p_email;
        
        COMMIT;
        
        p_success := 1;
        p_message := 'New verification code sent to your email';
    ELSE
        p_message := 'No pending registration found for this email. Please register first.';
        p_success := 0;
    END IF;
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        p_success := 0;
        p_message := 'Error resending verification code: ' || SQLERRM;
END ResendVerificationCode;
/


CREATE OR REPLACE PROCEDURE VerifyRegistration(
    p_email            IN PendingRegistration.email%TYPE,
    p_verification_code IN PendingRegistration.verification_code%TYPE,
    p_program          IN Student.program%TYPE,
    p_intake_year      IN Student.intake_year%TYPE,
    p_success          OUT NUMBER,
    p_message          OUT VARCHAR2
)
AS
    v_pending_record PendingRegistration%ROWTYPE;
    v_user_exists NUMBER;
BEGIN
    /*
    PURPOSE: Complete registration by verifying OTP
    CALLED: After user receives and enters OTP
    */
    
    p_success := 0;
    p_message := '';
    
    -- Check if OTP is valid and not expired
    BEGIN
        SELECT * INTO v_pending_record
        FROM PendingRegistration
        WHERE email = p_email 
          AND verification_code = p_verification_code
          AND code_expiry > SYSTIMESTAMP;
        
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            -- Check if OTP exists but expired
            SELECT COUNT(*) INTO v_user_exists
            FROM PendingRegistration
            WHERE email = p_email AND verification_code = p_verification_code;
            
            IF v_user_exists > 0 THEN
                p_message := 'Verification code has expired';
            ELSE
                p_message := 'Invalid verification code';
            END IF;
            RETURN;
    END;
    
    -- Check if user already exists
    SELECT COUNT(*) INTO v_user_exists
    FROM User_Table
    WHERE erp = v_pending_record.erp OR email = p_email;
    
    IF v_user_exists > 0 THEN
        p_message := 'User already registered';
        DELETE FROM PendingRegistration WHERE email = p_email;
        COMMIT;
        RETURN;
    END IF;
    
    -- Start transaction
    SAVEPOINT before_verification;
    
    -- Insert into User_Table
    INSERT INTO User_Table (
        ERP, name, email, user_password, role, phone_number,
        verification_code, code_expiry
    ) VALUES (
        v_pending_record.erp,
        v_pending_record.name,
        v_pending_record.email,
        v_pending_record.user_password,
        'Student',
        v_pending_record.phone_number,
        NULL,
        NULL
    );
    
    -- Insert into Student table (using provided program/intake_year)
    INSERT INTO Student (ERP, program, intake_year)
    VALUES (
        v_pending_record.erp,
        p_program,
        p_intake_year
    );
    
    -- Remove from pending
    DELETE FROM PendingRegistration WHERE email = p_email;
    
    COMMIT;
    
    p_success := 1;
    p_message := 'Registration completed successfully';
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK TO before_verification;
        p_success := 0;
        p_message := 'Verification failed: ' || SQLERRM;
END VerifyRegistration;
/

CREATE OR REPLACE PROCEDURE StudentLogin(
    p_identifier  IN VARCHAR2,  -- Can be email OR phone
    p_password    IN VARCHAR2,
    p_success     OUT NUMBER,
    p_erp         OUT NUMBER,
    p_name        OUT VARCHAR2,
    p_program     OUT VARCHAR2,
    p_intake_year OUT NUMBER,
    p_message     OUT VARCHAR2
)
AS
    v_is_email BOOLEAN;
BEGIN
    /*
    PURPOSE: Authenticate student user
    CALLED: Student login attempt
    */
    
    p_success := 0;
    p_erp := NULL;
    p_name := NULL;
    p_program := NULL;
    p_intake_year := NULL;
    p_message := '';
    
    -- Determine identifier type
    v_is_email := INSTR(p_identifier, '@') > 0;
    
    IF v_is_email THEN
        -- Login with email
        BEGIN
            SELECT u.erp, u.name, s.program, s.intake_year
            INTO p_erp, p_name, p_program, p_intake_year
            FROM User_Table u
            JOIN Student s ON u.ERP = s.ERP
            WHERE u.email = p_identifier
              AND u.user_password = p_password
              AND u.role = 'Student';
            
            p_success := 1;
            p_message := 'Login successful';
            
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                p_message := 'Invalid email or password';
            WHEN TOO_MANY_ROWS THEN
                p_message := 'System error: Multiple accounts found';
        END;
    ELSE
        -- Login with phone
        BEGIN
            SELECT u.erp, u.name, s.program, s.intake_year
            INTO p_erp, p_name, p_program, p_intake_year
            FROM User_Table u
            JOIN Student s ON u.ERP = s.ERP
            WHERE u.phone_number = p_identifier
              AND u.user_password = p_password
              AND u.role = 'Student';
            
            p_success := 1;
            p_message := 'Login successful';
            
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                p_message := 'Invalid phone number or password';
            WHEN TOO_MANY_ROWS THEN
                p_message := 'System error: Multiple accounts found';
        END;
    END IF;
    
END StudentLogin;
/



CREATE OR REPLACE PROCEDURE AdminLogin(
    p_identifier IN VARCHAR2,  -- Can be email OR phone
    p_password   IN VARCHAR2,
    p_success    OUT NUMBER,
    p_role       OUT VARCHAR2,
    p_erp        OUT NUMBER,
    p_name       OUT VARCHAR2,
    p_message    OUT VARCHAR2
)
AS
    v_is_email BOOLEAN;
BEGIN
    /*
    PURPOSE: Authenticate admin users (ProgramOffice or BuildingIncharge)
    CALLED: Admin login attempt
    */
    
    p_success := 0;
    p_role := NULL;
    p_erp := NULL;
    p_name := NULL;
    p_message := '';
    
    -- Determine identifier type
    v_is_email := INSTR(p_identifier, '@') > 0;
    
    IF v_is_email THEN
        -- Login with email
        BEGIN
            SELECT erp, name, role
            INTO p_erp, p_name, p_role
            FROM User_Table
            WHERE email = p_identifier
              AND user_password = p_password
              AND role IN ('ProgramOffice', 'BuildingIncharge');
            
            p_success := 1;
            p_message := 'Admin login successful';
            
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                p_message := 'Invalid admin credentials';
        END;
    ELSE
        -- Login with phone
        BEGIN
            SELECT erp, name, role
            INTO p_erp, p_name, p_role
            FROM User_Table
            WHERE phone_number = p_identifier
              AND user_password = p_password
              AND role IN ('ProgramOffice', 'BuildingIncharge');
            
            p_success := 1;
            p_message := 'Admin login successful';
            
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                p_message := 'Invalid admin credentials';
        END;
    END IF;
    
END AdminLogin;
/


CREATE OR REPLACE PROCEDURE CleanExpiredRegistrations
AS
    v_deleted_count NUMBER;
BEGIN
    /*
    PURPOSE: Clean up expired pending registrations
    CALLED: Scheduled job (daily/weekly)
    */
    
    DELETE FROM PendingRegistration
    WHERE code_expiry < SYSTIMESTAMP;
    
    v_deleted_count := SQL%ROWCOUNT;
    
    COMMIT;
    
    -- Optional: Log cleanup
    DBMS_OUTPUT.PUT_LINE('Cleaned ' || v_deleted_count || ' expired registrations');
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Cleanup error: ' || SQLERRM);
END CleanExpiredRegistrations;
/

CREATE OR REPLACE TRIGGER trg_check_student_role
BEFORE INSERT ON Student
FOR EACH ROW
DECLARE
    v_user_role User_Table.role%TYPE;
BEGIN
    -- Check that the user has 'Student' role
    SELECT role INTO v_user_role
    FROM User_Table
    WHERE ERP = :NEW.ERP;
    
    IF v_user_role != 'Student' THEN
        RAISE_APPLICATION_ERROR(-20001, 
            'Only users with Student role can have Student records');
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20002, 'User not found in User_Table');
END;
/

CREATE OR REPLACE TRIGGER trg_check_incharge_role
BEFORE INSERT ON Incharge
FOR EACH ROW
DECLARE
    v_user_role User_Table.role%TYPE;
BEGIN
    -- Check that the user has 'BuildingIncharge' role
    SELECT role INTO v_user_role
    FROM User_Table
    WHERE ERP = :NEW.incharge_id;
    
    IF v_user_role != 'BuildingIncharge' THEN
        RAISE_APPLICATION_ERROR(-20003, 
            'Only BuildingIncharge users can be assigned to buildings');
    END IF;
END;
/


CREATE OR REPLACE TRIGGER trg_booking_status_change
BEFORE UPDATE OF status ON Booking
FOR EACH ROW
BEGIN
    -- Log status changes (optional)
    IF :OLD.status != :NEW.status THEN
        DBMS_OUTPUT.PUT_LINE('Booking ' || :OLD.booking_id || 
            ' changed from ' || :OLD.status || ' to ' || :NEW.status);
    END IF;
END;
/

CREATE OR REPLACE PROCEDURE ShowReservationHistoryForStudent(
    p_erp    IN Booking.ERP%TYPE,
    p_result OUT SYS_REFCURSOR
)
AS
BEGIN
    /*
    PURPOSE: Show booking history for a specific student
    CALLED BY: Student to view their own bookings
    */
    
    OPEN p_result FOR
        SELECT 
            b.booking_id,
            b.room_id,
            r.room_name,
            bld.building_name,  -- Changed from b.building_name to bld.building_name
            b.booking_date,
            b.start_time,
            b.end_time,
            b.purpose,
            b.status,
            b.created_date
        FROM Booking b
        JOIN Room r ON b.room_id = r.room_id
        JOIN Building bld ON r.building_id = bld.building_id
        WHERE b.ERP = p_erp
        ORDER BY b.booking_date DESC, b.start_time DESC;
END;
/

CREATE OR REPLACE PROCEDURE CancelBookingByStudent(
    p_booking_id IN Booking.booking_id%TYPE,
    p_erp        IN Booking.ERP%TYPE,
    p_success    OUT NUMBER,
    p_message    OUT VARCHAR2
)
AS
    v_booking_exists NUMBER;
    v_current_status Booking.status%TYPE;
    v_start_datetime TIMESTAMP;
BEGIN
    /*
    PURPOSE: Allow student to cancel their own booking
    RULES: Can only cancel 'Approved' bookings, not already started
    */
    
    p_success := 0;
    p_message := '';
    
    -- Check booking exists and belongs to student
    SELECT COUNT(*), status, booking_date + (start_time - TRUNC(start_time))
    INTO v_booking_exists, v_current_status, v_start_datetime
    FROM Booking
    WHERE booking_id = p_booking_id 
      AND ERP = p_erp;
    
    IF v_booking_exists = 0 THEN
        p_message := 'Booking not found or does not belong to you';
        RETURN;
    END IF;
    
    -- Check status is 'Approved'
    IF v_current_status != 'Approved' THEN
        p_message := 'Only Approved bookings can be cancelled';
        RETURN;
    END IF;
    
    -- Check booking hasn't started
    IF v_start_datetime <= SYSTIMESTAMP THEN
        p_message := 'Cannot cancel booking that has already started';
        RETURN;
    END IF;
    
    -- Cancel the booking
    UPDATE Booking
    SET status = 'Cancelled'
    WHERE booking_id = p_booking_id;
    
    COMMIT;
    
    p_success := 1;
    p_message := 'Booking cancelled successfully';
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        p_success := 0;
        p_message := 'Error cancelling booking: ' || SQLERRM;
END;
/

CREATE OR REPLACE PROCEDURE ShowReservationHistoryForPO(
    p_result OUT SYS_REFCURSOR
)
AS
BEGIN
    /*
    PURPOSE: Show all classroom bookings for Program Office
    CALLED BY: Program Office admin
    */
    
    OPEN p_result FOR
        SELECT 
            b.booking_id,
            b.ERP,
            u.name AS student_name,
            r.room_name,
            bld.building_name,
            b.booking_date,
            b.start_time,
            b.end_time,
            b.purpose,
            b.status,
            b.created_date
        FROM Booking b
        JOIN Room r ON b.room_id = r.room_id
        JOIN Building bld ON r.building_id = bld.building_id
        JOIN User_Table u ON b.ERP = u.ERP
        WHERE r.room_type = 'CLASSROOM'
        ORDER BY b.booking_date DESC, b.start_time DESC;
END;
/

CREATE OR REPLACE PROCEDURE ShowReservationHistoryForBI(
    p_incharge_id IN Incharge.incharge_id%TYPE,
    p_result      OUT SYS_REFCURSOR
)
AS
    v_building_id Building.building_id%TYPE;
BEGIN
    /*
    PURPOSE: Show breakout bookings for specific building incharge
    CALLED BY: Building Incharge for their building only
    */
    
    -- Get building assigned to this incharge
    SELECT building_id INTO v_building_id
    FROM Incharge
    WHERE incharge_id = p_incharge_id;
    
    OPEN p_result FOR
        SELECT 
            b.booking_id,
            b.ERP,
            u.name AS student_name,
            r.room_name,
            bld.building_name,
            b.booking_date,
            b.start_time,
            b.end_time,
            b.purpose,
            b.status,
            b.created_date
        FROM Booking b
        JOIN Room r ON b.room_id = r.room_id
        JOIN Building bld ON r.building_id = bld.building_id
        JOIN User_Table u ON b.ERP = u.ERP
        WHERE r.room_type = 'BREAKOUT'
          AND r.building_id = v_building_id
        ORDER BY b.booking_date DESC, b.start_time DESC;
        
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        p_result := NULL;
END;
/

CREATE OR REPLACE PROCEDURE RejectBookingByPO(
    p_booking_id IN Booking.booking_id%TYPE,
    p_success    OUT NUMBER,
    p_message    OUT VARCHAR2
)
AS
    v_room_type Room.room_type%TYPE;
    v_status    Booking.status%TYPE;
BEGIN
    /*
    PURPOSE: PO can reject classroom bookings
    RULES: Only 'Approved' classrooms can be rejected
    */
    
    p_success := 0;
    p_message := '';
    
    -- Get booking details
    SELECT r.room_type, b.status
    INTO v_room_type, v_status
    FROM Booking b
    JOIN Room r ON b.room_id = r.room_id
    WHERE b.booking_id = p_booking_id;
    
    -- Check it's a classroom
    IF v_room_type != 'CLASSROOM' THEN
        p_message := 'Only classroom bookings can be rejected by PO';
        RETURN;
    END IF;
    
    -- Check status is 'Approved'
    IF v_status != 'Approved' THEN
        p_message := 'Only Approved bookings can be rejected';
        RETURN;
    END IF;
    
    -- Reject the booking
    UPDATE Booking
    SET status = 'Rejected'
    WHERE booking_id = p_booking_id;
    
    COMMIT;
    
    p_success := 1;
    p_message := 'Booking rejected successfully';
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        p_message := 'Booking not found';
    WHEN OTHERS THEN
        ROLLBACK;
        p_message := 'Error rejecting booking: ' || SQLERRM;
END;
/

CREATE OR REPLACE PROCEDURE RejectBookingByBI(
    p_booking_id  IN Booking.booking_id%TYPE,
    p_incharge_id IN Incharge.incharge_id%TYPE,
    p_success     OUT NUMBER,
    p_message     OUT VARCHAR2
)
AS
    v_room_type   Room.room_type%TYPE;
    v_status      Booking.status%TYPE;
    v_building_id Building.building_id%TYPE;
    v_room_building_id Room.building_id%TYPE;
BEGIN
    /*
    PURPOSE: BI can reject breakout bookings in their building
    RULES: Only 'Approved' breakouts in their building can be rejected
    */
    
    p_success := 0;
    p_message := '';
    
    -- Get BI's building
    SELECT building_id INTO v_building_id
    FROM Incharge
    WHERE incharge_id = p_incharge_id;
    
    -- Get booking details
    SELECT r.room_type, b.status, r.building_id
    INTO v_room_type, v_status, v_room_building_id
    FROM Booking b
    JOIN Room r ON b.room_id = r.room_id
    WHERE b.booking_id = p_booking_id;
    
    -- Check it's a breakout in BI's building
    IF v_room_type != 'BREAKOUT' THEN
        p_message := 'Only breakout bookings can be rejected by BI';
        RETURN;
    END IF;
    
    IF v_room_building_id != v_building_id THEN
        p_message := 'Cannot reject bookings from other buildings';
        RETURN;
    END IF;
    
    -- Check status is 'Approved'
    IF v_status != 'Approved' THEN
        p_message := 'Only Approved bookings can be rejected';
        RETURN;
    END IF;
    
    -- Reject the booking
    UPDATE Booking
    SET status = 'Rejected'
    WHERE booking_id = p_booking_id;
    
    COMMIT;
    
    p_success := 1;
    p_message := 'Booking rejected successfully';
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        p_message := 'Booking not found';
    WHEN OTHERS THEN
        ROLLBACK;
        p_message := 'Error rejecting booking: ' || SQLERRM;
END;
/


CREATE OR REPLACE PROCEDURE PostAnnouncement(
    p_erp          IN Announcement.ERP%TYPE,
    p_title        IN Announcement.title%TYPE,
    p_description  IN Announcement.description%TYPE,
    p_success      OUT NUMBER,
    p_message      OUT VARCHAR2
)
AS
    v_role User_Table.role%TYPE;
    v_incharge_exists NUMBER;
BEGIN
    /*
    PURPOSE: Building Incharge posts announcement for their building
    RULES: Only BuildingIncharge role can post announcements
    */
    
    p_success := 0;
    p_message := '';
    
    -- Check user is BuildingIncharge
    SELECT role INTO v_role
    FROM User_Table
    WHERE ERP = p_erp;
    
    IF v_role != 'BuildingIncharge' THEN
        p_message := 'Only Building Incharges can post announcements';
        RETURN;
    END IF;
    
    -- Check incharge is assigned to a building
    SELECT COUNT(*) INTO v_incharge_exists
    FROM Incharge
    WHERE incharge_id = p_erp;
    
    IF v_incharge_exists = 0 THEN
        p_message := 'Building Incharge not assigned to any building';
        RETURN;
    END IF;
    
    -- Insert announcement
    INSERT INTO Announcement (
        ERP, title, description, date_posted
    ) VALUES (
        p_erp, p_title, p_description, SYSTIMESTAMP
    );
    
    COMMIT;
    
    p_success := 1;
    p_message := 'Announcement posted successfully';
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        p_success := 0;
        p_message := 'Error posting announcement: ' || SQLERRM;
END;
/

CREATE OR REPLACE PROCEDURE DeleteAnnouncement(
    p_announcement_id IN Announcement.announcement_id%TYPE,
    p_erp             IN Announcement.ERP%TYPE,
    p_success         OUT NUMBER,
    p_message         OUT VARCHAR2
)
AS
    v_announcement_exists NUMBER;
BEGIN
    /*
    PURPOSE: Delete announcement posted by user
    RULES: User can only delete their own announcements
    */
    
    p_success := 0;
    p_message := '';
    
    -- Check announcement exists and belongs to user
    SELECT COUNT(*) INTO v_announcement_exists
    FROM Announcement
    WHERE announcement_id = p_announcement_id
      AND ERP = p_erp;
    
    IF v_announcement_exists = 0 THEN
        p_message := 'Announcement not found or you do not have permission';
        RETURN;
    END IF;
    
    -- Delete announcement
    DELETE FROM Announcement
    WHERE announcement_id = p_announcement_id
      AND ERP = p_erp;
    
    COMMIT;
    
    p_success := 1;
    p_message := 'Announcement deleted successfully';
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        p_success := 0;
        p_message := 'Error deleting announcement: ' || SQLERRM;
END;
/

CREATE OR REPLACE PROCEDURE ShowAnnouncementsByUser(
    p_erp     IN Announcement.ERP%TYPE,
    p_result  OUT SYS_REFCURSOR
)
AS
BEGIN
    /*
    PURPOSE: Show announcements posted by specific user
    CALLED BY: User to see their own announcements
    */
    
    OPEN p_result FOR
        SELECT 
            announcement_id,
            title,
            description,
            date_posted,
            created_date
        FROM Announcement
        WHERE ERP = p_erp
        ORDER BY date_posted DESC;
END;
/

CREATE OR REPLACE PROCEDURE ShowAllAnnouncements(
    p_result OUT SYS_REFCURSOR
)
AS
BEGIN
    /*
    PURPOSE: Show all announcements for students
    CALLED BY: Students to see all announcements
    */
    
    OPEN p_result FOR
        SELECT 
            a.announcement_id,
            a.title,
            a.description,
            a.date_posted,
            u.name AS posted_by,
            b.building_name
        FROM Announcement a
        JOIN User_Table u ON a.ERP = u.ERP
        LEFT JOIN Incharge i ON a.ERP = i.incharge_id
        LEFT JOIN Building b ON i.building_id = b.building_id
        ORDER BY a.date_posted DESC;
END;
/

CREATE OR REPLACE PROCEDURE FilterAnnouncementsByBuilding(
    p_building_name IN Building.building_name%TYPE,
    p_result      OUT SYS_REFCURSOR
)
AS
    v_building_exists NUMBER;
BEGIN
    /*
    PURPOSE: Show announcements for specific building
    CALLED BY: Filter announcements by building
    */
    
    -- Check building exists
    SELECT COUNT(*) INTO v_building_exists
    FROM Building
    WHERE UPPER(building_name) = UPPER(p_building_name);
    
    IF v_building_exists = 0 THEN
        p_result := NULL;
        RETURN;
    END IF;
    
    OPEN p_result FOR
        SELECT 
            a.announcement_id,
            a.title,
            a.description,
            a.date_posted,
            u.name AS posted_by,
            b.building_name
        FROM Announcement a
        JOIN User_Table u ON a.ERP = u.ERP
        JOIN Incharge i ON a.ERP = i.incharge_id
        JOIN Building b ON i.building_id = b.building_id
        WHERE UPPER(b.building_name) = UPPER(p_building_name)  -- Fixed: compare by name
        ORDER BY a.date_posted DESC;
        
END;
/


CREATE OR REPLACE TRIGGER trg_booking_status_notification
AFTER UPDATE OF status ON Booking
FOR EACH ROW
BEGIN
    -- Log status changes for notification system
    IF :OLD.status != :NEW.status THEN
        -- This would typically call a notification procedure
        -- For now, just log it
        DBMS_OUTPUT.PUT_LINE(
            'Booking ' || :OLD.booking_id || 
            ' status changed from ' || :OLD.status || 
            ' to ' || :NEW.status || 
            ' for user ERP: ' || :OLD.ERP
        );
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_validate_booking
BEFORE INSERT ON Booking
FOR EACH ROW
DECLARE
    v_conflict_count NUMBER;
    v_schedule_count NUMBER;
    v_day_of_week VARCHAR2(10);
BEGIN
    /*
    PURPOSE: Validate booking doesn't conflict with schedule or other bookings
    RULES: 
    1. No conflict with scheduled classes
    2. No conflict with other 'Approved' bookings
    3. Booking must be for future
    */
    
    -- Get day of week for schedule check
    v_day_of_week := UPPER(TO_CHAR(:NEW.booking_date, 'DAY'));
    
    -- Check schedule conflicts
    SELECT COUNT(*) INTO v_schedule_count
    FROM Schedule s
    WHERE s.room_id = :NEW.room_id
      AND s.day_of_week = v_day_of_week
      AND NOT (
          s.end_time <= :NEW.start_time OR 
          s.start_time >= :NEW.end_time
      );
    
    IF v_schedule_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20010, 'Room is scheduled for classes during this time');
    END IF;
    
    -- Check booking conflicts (only check 'Approved' bookings)
    SELECT COUNT(*) INTO v_conflict_count
    FROM Booking b
    WHERE b.room_id = :NEW.room_id
      AND b.booking_date = :NEW.booking_date
      AND b.status = 'Approved'
      AND NOT (
          b.end_time <= :NEW.start_time OR 
          b.start_time >= :NEW.end_time
      );
    
    IF v_conflict_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20011, 'Room already booked for this time slot');
    END IF;
    
    -- Auto-set status to 'Approved' (since no conflicts)
    :NEW.status := 'Approved';
    
END;
/


CREATE OR REPLACE PROCEDURE ViewRoomsByType(
    p_room_type IN Room.room_type%TYPE,
    p_result    OUT SYS_REFCURSOR
)
AS
BEGIN
    /*
    PURPOSE: View all rooms of a specific type
    INPUT: Room type (CLASSROOM/BREAKOUT)
    OUTPUT: All rooms matching the type
    */
    
    OPEN p_result FOR
        SELECT 
            r.room_id,
            r.room_name,
            r.room_type,
            b.building_id,
            b.building_name
        FROM Room r
        JOIN Building b ON r.building_id = b.building_id
        WHERE r.room_type = p_room_type
        ORDER BY b.building_name, r.room_name;
        
END ViewRoomsByType;
/

CREATE OR REPLACE PROCEDURE ViewRoomsByTypeBuilding(
    p_room_type   IN Room.room_type%TYPE,
    p_building_id IN Building.building_id%TYPE,
    p_result      OUT SYS_REFCURSOR
)
AS
    v_building_exists NUMBER;
BEGIN
    /*
    PURPOSE: View rooms of specific type in specific building
    INPUT: Room type + Building ID
    OUTPUT: Rooms matching both criteria
    */
    
    -- Check if building exists
    SELECT COUNT(*) INTO v_building_exists
    FROM Building
    WHERE building_id = p_building_id;
    
    IF v_building_exists = 0 THEN
        -- Return empty cursor if building doesn't exist
        OPEN p_result FOR
            SELECT 
                r.room_id,
                r.room_name,
                r.room_type,
                b.building_id,
                b.building_name
            FROM Room r
            JOIN Building b ON r.building_id = b.building_id
            WHERE 1 = 0; -- Always false
        RETURN;
    END IF;
    
    OPEN p_result FOR
        SELECT 
            r.room_id,
            r.room_name,
            r.room_type,
            b.building_id,
            b.building_name
        FROM Room r
        JOIN Building b ON r.building_id = b.building_id
        WHERE r.room_type = p_room_type
          AND r.building_id = p_building_id
        ORDER BY r.room_name;
        
END ViewRoomsByTypeBuilding;
/

CREATE OR REPLACE PROCEDURE ViewRoomsByTypeName(
    p_room_type IN Room.room_type%TYPE,
    p_room_name IN Room.room_name%TYPE,
    p_result    OUT SYS_REFCURSOR
)
AS
BEGIN
    /*
    PURPOSE: Search rooms by type and name (partial match)
    INPUT: Room type + Room name (can be partial)
    OUTPUT: Rooms matching type and containing search term in name
    */
    
    OPEN p_result FOR
        SELECT 
            r.room_id,
            r.room_name,
            r.room_type,
            b.building_id,
            b.building_name
        FROM Room r
        JOIN Building b ON r.building_id = b.building_id
        WHERE r.room_type = p_room_type
          AND UPPER(r.room_name) LIKE '%' || UPPER(p_room_name) || '%'
        ORDER BY b.building_name, r.room_name;
        
END ViewRoomsByTypeName;
/

CREATE OR REPLACE PROCEDURE ViewAllRooms(
    p_result OUT SYS_REFCURSOR
)
AS
BEGIN
    /*
    PURPOSE: View all rooms regardless of type
    OUTPUT: All rooms in system
    */
    
    OPEN p_result FOR
        SELECT 
            r.room_id,
            r.room_name,
            r.room_type,
            b.building_id,
            b.building_name
        FROM Room r
        JOIN Building b ON r.building_id = b.building_id
        ORDER BY b.building_name, r.room_type, r.room_name;
        
END ViewAllRooms;
/

-- ============================================
-- BUILDING MANAGEMENT PROCEDURES
-- ============================================

-- Note: Sequences are not needed since you use IDENTITY columns
-- Remove the sequence creation since you already have IDENTITY

CREATE OR REPLACE PROCEDURE add_building(
    p_building_name IN Building.building_name%TYPE,
    p_incharge_erp IN User_Table.ERP%TYPE,
    p_incharge_name IN User_Table.name%TYPE,
    p_incharge_email IN User_Table.email%TYPE,
    p_phonenumber IN User_Table.phone_number%TYPE,
    p_result OUT VARCHAR2
)
AS
    v_building_count NUMBER;
    v_building_id Building.building_id%TYPE;
    v_user_count NUMBER;
    v_incharge_count NUMBER;
BEGIN
    -- Step 1: Check if building already exists by name
    SELECT COUNT(*) INTO v_building_count 
    FROM Building 
    WHERE UPPER(building_name) = UPPER(p_building_name);
    
    -- If building exists, return error message
    IF v_building_count > 0 THEN
        p_result := 'Building "' || p_building_name || '" already exists';
        RETURN;
    END IF;
    
    -- Step 2: Check if incharge ERP exists in User_Table
    SELECT COUNT(*) INTO v_user_count 
    FROM User_Table 
    WHERE ERP = p_incharge_erp;
    
    -- Step 3: Check if incharge is already assigned to another building
    SELECT COUNT(*) INTO v_incharge_count
    FROM Incharge
    WHERE incharge_id = p_incharge_erp;
    
    -- If incharge is already assigned to another building, return error
    IF v_incharge_count > 0 THEN
        p_result := 'Incharge with ERP ' || p_incharge_erp || ' is already assigned to another building';
        RETURN;
    END IF;
    
    -- Step 4: If incharge doesn't exist in User_Table, add them
    IF v_user_count = 0 THEN
        -- Use consistent role name from your existing code ('BuildingIncharge')
        INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number)
        VALUES (p_incharge_erp, p_incharge_name, p_incharge_email, 'default_password', 'BuildingIncharge', p_phonenumber);
    END IF;
    
    -- Step 5: Insert the new building (ID will auto-generate)
    INSERT INTO Building (building_name)
    VALUES (p_building_name)
    RETURNING building_id INTO v_building_id;
    
    -- Step 6: Assign incharge to the building
    INSERT INTO Incharge (incharge_id, building_id)
    VALUES (p_incharge_erp, v_building_id);
    
    -- Step 7: Set success message with building ID
    p_result := 'Building "' || p_building_name || '" added successfully with ID: ' || v_building_id || '. Incharge assigned.';
    
    -- Commit the transaction
    COMMIT;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Handle any exceptions and return error message
        p_result := 'Error adding building: ' || SQLERRM;
        ROLLBACK;
END add_building;
/

CREATE OR REPLACE PROCEDURE add_room(
    p_building_name IN Building.building_name%TYPE,
    p_room_name IN Room.room_name%TYPE,
    p_room_type IN Room.room_type%TYPE,
    p_result OUT VARCHAR2
)
AS
    v_building_count NUMBER;
    v_room_count NUMBER;
    v_building_id Building.building_id%TYPE;
    v_room_id Room.room_id%TYPE;
BEGIN
    -- Step 1: Check if building exists
    BEGIN
        SELECT building_id INTO v_building_id
        FROM Building 
        WHERE UPPER(building_name) = UPPER(p_building_name);
        
        v_building_count := 1;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            v_building_count := 0;
    END;
    
    -- If building doesn't exist, return error message
    IF v_building_count = 0 THEN
        p_result := 'Building "' || p_building_name || '" does not exist. Please add building first.';
        RETURN;
    END IF;
    
    -- Step 2: Check if room already exists in this building
    SELECT COUNT(*) INTO v_room_count 
    FROM Room 
    WHERE UPPER(room_name) = UPPER(p_room_name)
    AND building_id = v_building_id;
    
    -- If room exists, return error message
    IF v_room_count > 0 THEN
        p_result := 'Room "' || p_room_name || '" already exists in building "' || p_building_name || '"';
        RETURN;
    END IF;
    
    -- Step 3: Insert the new room (ID will auto-generate)
    INSERT INTO Room (building_id, room_name, room_type)
    VALUES (v_building_id, p_room_name, p_room_type)
    RETURNING room_id INTO v_room_id;
    
    -- Step 4: Set success message
    p_result := 'Room "' || p_room_name || '" added successfully to building "' || p_building_name || '" with ID: ' || v_room_id;
    
    -- Commit the transaction
    COMMIT;
    
EXCEPTION
    WHEN OTHERS THEN
        -- Handle any exceptions and return error message
        p_result := 'Error adding room: ' || SQLERRM;
        ROLLBACK;
END add_room;
/

-- This procedure already exists as ViewAllRooms, but keeping for compatibility
CREATE OR REPLACE PROCEDURE get_buildings(
    p_cursor OUT SYS_REFCURSOR
)
AS
BEGIN
    OPEN p_cursor FOR
    SELECT building_id, building_name 
    FROM Building 
    ORDER BY building_name;
END get_buildings;
/

-- ============================================
-- BOOKING MANAGEMENT PROCEDURES
-- ============================================

CREATE OR REPLACE PROCEDURE get_available_rooms(
    p_date IN DATE,
    p_start_time IN VARCHAR2,
    p_end_time IN VARCHAR2,
    p_building_id IN NUMBER,
    p_room_type IN VARCHAR2,
    p_cursor OUT SYS_REFCURSOR
)
AS
    v_start_datetime TIMESTAMP;  -- Changed from DATE to TIMESTAMP to match your schema
    v_end_datetime TIMESTAMP;    -- Changed from DATE to TIMESTAMP to match your schema
    v_day_of_week VARCHAR2(10);  -- Changed to match your Schedule.day_of_week
BEGIN
    -- Convert time strings to datetime
    v_start_datetime := TO_TIMESTAMP(TO_CHAR(p_date, 'YYYY-MM-DD') || ' ' || p_start_time, 'YYYY-MM-DD HH24:MI');
    v_end_datetime := TO_TIMESTAMP(TO_CHAR(p_date, 'YYYY-MM-DD') || ' ' || p_end_time, 'YYYY-MM-DD HH24:MI');
    v_day_of_week := UPPER(TO_CHAR(p_date, 'DAY'));  -- Get day of week
    
    OPEN p_cursor FOR
    SELECT 
        r.room_id,
        r.room_name,
        r.room_type,
        b.building_name,
        b.building_id
    FROM Room r
    JOIN Building b ON r.building_id = b.building_id
    WHERE b.building_id = p_building_id
    AND r.room_type = p_room_type
    AND r.room_id NOT IN (
        -- Rooms already booked for this time slot (only approved bookings block availability)
        SELECT room_id FROM Booking
        WHERE booking_date = p_date  -- Changed from date_of_booking to booking_date
        AND status = 'Approved'  -- Changed to match your schema (capitalized)
        AND NOT (
            end_time <= v_start_datetime OR 
            start_time >= v_end_datetime
        )
    )
    AND r.room_id NOT IN (
        -- Rooms scheduled for classes
        SELECT room_id FROM Schedule
        WHERE day_of_week = v_day_of_week  -- Changed from day to day_of_week
        AND NOT (
            end_time <= v_start_datetime OR 
            start_time >= v_end_datetime
        )
    )
    ORDER BY r.room_name;
END get_available_rooms;
/

CREATE OR REPLACE PROCEDURE create_booking(
    p_erp IN NUMBER,
    p_room_id IN NUMBER,
    p_date_of_booking IN DATE,
    p_start_time IN VARCHAR2,
    p_end_time IN VARCHAR2,
    p_purpose IN VARCHAR2,
    p_booking_id OUT NUMBER,
    p_success OUT NUMBER,
    p_message OUT VARCHAR2
)
AS
    v_start_datetime TIMESTAMP;  -- Changed to TIMESTAMP
    v_end_datetime TIMESTAMP;    -- Changed to TIMESTAMP
    v_conflict_count NUMBER;
    v_schedule_count NUMBER;
    v_current_date DATE := SYSDATE;
    v_day_of_week VARCHAR2(10);  -- Changed to match your schema
BEGIN
    p_success := 0;
    p_message := 'Booking failed';
    
    -- Validate that booking date is today or in the future (not in the past)
    IF TRUNC(p_date_of_booking) < TRUNC(v_current_date) THEN
        p_message := 'Booking date cannot be in the past. Please select today or a future date.';
        RETURN;
    END IF;
    
    -- Convert time strings to datetime
    v_start_datetime := TO_TIMESTAMP(TO_CHAR(p_date_of_booking, 'YYYY-MM-DD') || ' ' || p_start_time, 'YYYY-MM-DD HH24:MI');
    v_end_datetime := TO_TIMESTAMP(TO_CHAR(p_date_of_booking, 'YYYY-MM-DD') || ' ' || p_end_time, 'YYYY-MM-DD HH24:MI');
    v_day_of_week := UPPER(TO_CHAR(p_date_of_booking, 'DAY'));  -- Get day of week
    
    -- If booking is for today, validate that start time is not in the past
    IF TRUNC(p_date_of_booking) = TRUNC(v_current_date) THEN
        IF v_start_datetime < SYSTIMESTAMP THEN  -- Changed to SYSTIMESTAMP for timestamp comparison
            p_message := 'Start time cannot be in the past for today''s booking.';
            RETURN;
        END IF;
    END IF;
    
    -- Validate end time is after start time
    IF v_end_datetime <= v_start_datetime THEN
        p_message := 'End time must be after start time.';
        RETURN;
    END IF;
    
    -- Check for booking conflicts (only check approved bookings)
    SELECT COUNT(*) INTO v_conflict_count
    FROM Booking
    WHERE room_id = p_room_id
    AND booking_date = p_date_of_booking  -- Changed from date_of_booking
    AND status = 'Approved'  -- Capitalized to match your schema
    AND NOT (
        end_time <= v_start_datetime OR 
        start_time >= v_end_datetime
    );
    
    -- Check for schedule conflicts
    SELECT COUNT(*) INTO v_schedule_count
    FROM Schedule
    WHERE room_id = p_room_id
    AND day_of_week = v_day_of_week  -- Changed from day
    AND NOT (
        end_time <= v_start_datetime OR 
        start_time >= v_end_datetime
    );
    
    IF v_conflict_count > 0 THEN
        p_message := 'Room already booked for this time slot';
        RETURN;
    END IF;
    
    IF v_schedule_count > 0 THEN
        p_message := 'Room is scheduled for classes during this time';
        RETURN;
    END IF;
    
    -- Insert the booking with 'Approved' status (capitalized to match your schema)
    INSERT INTO Booking (
        ERP, room_id, booking_date,  -- Changed from date_of_booking
        start_time, end_time, purpose, status
    ) VALUES (
        p_erp, p_room_id, p_date_of_booking,
        v_start_datetime, v_end_datetime, p_purpose, 'Approved'
    )
    RETURNING booking_id INTO p_booking_id;
    
    COMMIT;
    p_success := 1;
    p_message := 'Booking approved successfully!';
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        p_message := 'Error creating booking: ' || SQLERRM;
        p_success := 0;
END create_booking;
/

-- Remove or rename this trigger since you already have trg_validate_booking
-- The existing trg_validate_booking already handles validation
-- You can either remove this or rename it to avoid conflict

-- CREATE OR REPLACE TRIGGER check_room_availability_trigger
-- BEFORE INSERT ON Booking
-- FOR EACH ROW
-- DECLARE
--     v_conflict_count NUMBER;
--     v_schedule_count NUMBER;
-- BEGIN
--     -- Your existing trg_validate_booking already does this
--     -- So we don't need duplicate functionality
-- END;
-- /

-- ============================================
-- SAMPLE DATA INSERTIONS FOR IBA ROOM BOOKING SYSTEM
-- ============================================
BEGIN
    EXECUTE IMMEDIATE 'ALTER TRIGGER trg_check_student_role DISABLE';
    EXECUTE IMMEDIATE 'ALTER TRIGGER trg_check_incharge_role DISABLE';
    EXECUTE IMMEDIATE 'ALTER TRIGGER trg_booking_future_date DISABLE';
    EXECUTE IMMEDIATE 'ALTER TRIGGER trg_validate_booking DISABLE';
EXCEPTION
    WHEN OTHERS THEN NULL;
END;
/

-- ============================================
-- COMPLETE DATA INSERTION SCRIPT (NO BIND VARIABLES)
-- ============================================

-- 1. First, clear all existing data
BEGIN
    -- Delete in reverse order of dependencies
    DELETE FROM Booking;
    DELETE FROM Schedule;
    DELETE FROM Announcement;
    DELETE FROM Incharge;
    DELETE FROM Student;
    DELETE FROM PendingRegistration;
    DELETE FROM Room;
    DELETE FROM Building;
    DELETE FROM User_Table;
    COMMIT;
    
    DBMS_OUTPUT.PUT_LINE('All existing data cleared.');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error clearing data: ' || SQLERRM);
        ROLLBACK;
END;
/

-- 2. Enable output
SET SERVEROUTPUT ON;

-- ============================================
-- 3. INSERT BUILDINGS (uses IDENTITY)
-- ============================================
INSERT INTO Building (building_name) VALUES ('Adamjee');
INSERT INTO Building (building_name) VALUES ('Aman CED');
INSERT INTO Building (building_name) VALUES ('Tabba');
INSERT INTO Building (building_name) VALUES ('Executive Center');
INSERT INTO Building (building_name) VALUES ('Sports Complex');

COMMIT;

-- ============================================
-- 4. INSERT USERS WITH PROPER 8+ CHARACTER PASSWORDS
-- ============================================
-- Students
INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number) 
VALUES (10001, 'Muskan Ahmed', 'muskan@khi.iba.edu.pk', 'muskan1234', 'Student', '03123456701');

INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number) 
VALUES (10002, 'Kashish Khan', 'kashish@khi.iba.edu.pk', 'kashish1234', 'Student', '03123456702');

INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number) 
VALUES (10003, 'Mustafa Ali', 'mustafa@khi.iba.edu.pk', 'mustafa1234', 'Student', '03123456703');

INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number) 
VALUES (10004, 'Hiba Raza', 'hiba@khi.iba.edu.pk', 'hibaraza123', 'Student', '03123456704');

INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number) 
VALUES (10005, 'Abdullah Malik', 'abdullah@khi.iba.edu.pk', 'abdullah1234', 'Student', '03123456705');

-- Program Office
INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number) 
VALUES (20001, 'Ahsan Raza', 'ahsan@iba.edu.pk', 'Program1234', 'ProgramOffice', '03123456706');

-- Building Incharges
INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number) 
VALUES (30001, 'Mohsin Khan', 'mohsin@iba.edu.pk', 'Building1234', 'BuildingIncharge', '03123456707');

INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number) 
VALUES (30002, 'Taimoor Ahmed', 'taimoor@iba.edu.pk', 'Building1234', 'BuildingIncharge', '03123456708');

INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number) 
VALUES (30003, 'Zaid Hassan', 'zaid@iba.edu.pk', 'Building1234', 'BuildingIncharge', '03123456709');

INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number) 
VALUES (30004, 'Samreen Ali', 'samreen@iba.edu.pk', 'Building1234', 'BuildingIncharge', '03123456710');

INSERT INTO User_Table (ERP, name, email, user_password, role, phone_number) 
VALUES (30005, 'Maheen Shah', 'maheen@iba.edu.pk', 'Building1234', 'BuildingIncharge', '03123456711');

COMMIT;

-- ============================================
-- 5. INSERT STUDENT ACADEMIC INFO
-- ============================================
INSERT INTO Student (ERP, program, intake_year) VALUES (10001, 'BSCS', 2023);
INSERT INTO Student (ERP, program, intake_year) VALUES (10002, 'BSCS', 2023);
INSERT INTO Student (ERP, program, intake_year) VALUES (10003, 'BSMT', 2024);
INSERT INTO Student (ERP, program, intake_year) VALUES (10004, 'BBA', 2024);
INSERT INTO Student (ERP, program, intake_year) VALUES (10005, 'BSECO', 2025);

COMMIT;

-- ============================================
-- 6. INSERT ROOMS - FIRST CHECK BUILDING IDs
-- ============================================
-- First, check what building_ids were actually assigned
DECLARE
    v_adamjee_id NUMBER;
    v_aman_id NUMBER;
    v_tabba_id NUMBER;
    v_exec_id NUMBER;
    v_sports_id NUMBER;
BEGIN
    -- Get actual building IDs
    SELECT building_id INTO v_adamjee_id FROM Building WHERE building_name = 'Adamjee';
    SELECT building_id INTO v_aman_id FROM Building WHERE building_name = 'Aman CED';
    SELECT building_id INTO v_tabba_id FROM Building WHERE building_name = 'Tabba';
    SELECT building_id INTO v_exec_id FROM Building WHERE building_name = 'Executive Center';
    SELECT building_id INTO v_sports_id FROM Building WHERE building_name = 'Sports Complex';
    
    DBMS_OUTPUT.PUT_LINE('Building IDs: Adamjee=' || v_adamjee_id || 
                        ', Aman CED=' || v_aman_id || 
                        ', Tabba=' || v_tabba_id ||
                        ', Exec Center=' || v_exec_id ||
                        ', Sports=' || v_sports_id);
    
    -- Adamjee Building
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'AUDITORIUM', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'EVENT HALL', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'MAC-1', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'MAC-2', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'MAC-3', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'MAC-4', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'MAC-5', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'MAC-6', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'MAC-7', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'MAC-8', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'BREAKOUT-1', 'BREAKOUT');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_adamjee_id, 'BREAKOUT-2', 'BREAKOUT');

    -- Aman CED Building
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_aman_id, 'MCC-9', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_aman_id, 'MCC-10', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_aman_id, 'MCC-11', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_aman_id, 'MCC-12', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_aman_id, 'MCC-13', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_aman_id, 'MCC-14', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_aman_id, 'MC-BREAKOUT-1', 'BREAKOUT');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_aman_id, 'MC-BREAKOUT-2', 'BREAKOUT');

    -- Tabba Building
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_tabba_id, 'MTC-16', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_tabba_id, 'MTC-17', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_tabba_id, 'MTC-18', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_tabba_id, 'MTC-19', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_tabba_id, 'MT-BREAKOUT-1', 'BREAKOUT');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_tabba_id, 'MT-BREAKOUT-2', 'BREAKOUT');

    -- Executive Center
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_exec_id, 'EC-CONF-1', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_exec_id, 'EC-CONF-2', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_exec_id, 'EC-BOARD-ROOM', 'CLASSROOM');

    -- Sports Complex
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_sports_id, 'GYM', 'CLASSROOM');
    INSERT INTO Room (building_id, room_name, room_type) VALUES (v_sports_id, 'SPORTS-HALL', 'CLASSROOM');
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('30+ rooms inserted.');
    
    -- Store these IDs for later use in other procedures
    DBMS_OUTPUT.PUT_LINE('Stored building IDs for later use.');
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: Could not find one or more buildings. Check Building table.');
        ROLLBACK;
        RAISE;
END;
/

-- ============================================
-- 7. ASSIGN BUILDING INCHARGES - UPDATED WITH VARIABLES
-- ============================================
DECLARE
    v_adamjee_id NUMBER;
    v_aman_id NUMBER;
    v_tabba_id NUMBER;
    v_exec_id NUMBER;
    v_sports_id NUMBER;
BEGIN
    -- Get building IDs again (or you could store them in a package variable)
    SELECT building_id INTO v_adamjee_id FROM Building WHERE building_name = 'Adamjee';
    SELECT building_id INTO v_aman_id FROM Building WHERE building_name = 'Aman CED';
    SELECT building_id INTO v_tabba_id FROM Building WHERE building_name = 'Tabba';
    SELECT building_id INTO v_exec_id FROM Building WHERE building_name = 'Executive Center';
    SELECT building_id INTO v_sports_id FROM Building WHERE building_name = 'Sports Complex';
    
    -- Zaid (30003) for Adamjee
    INSERT INTO Incharge (incharge_id, building_id) VALUES (30003, v_adamjee_id);

    -- Taimoor (30002) for Aman CED
    INSERT INTO Incharge (incharge_id, building_id) VALUES (30002, v_aman_id);

    -- Mohsin (30001) for Tabba
    INSERT INTO Incharge (incharge_id, building_id) VALUES (30001, v_tabba_id);

    -- Maheen (30005) for Executive Center
    INSERT INTO Incharge (incharge_id, building_id) VALUES (30005, v_exec_id);

    -- Samreen (30004) for Sports Complex
    INSERT INTO Incharge (incharge_id, building_id) VALUES (30004, v_sports_id);

    COMMIT;
    DBMS_OUTPUT.PUT_LINE('5 building incharges assigned.');
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: Could not find buildings or incharges.');
        ROLLBACK;
        RAISE;
END;
/

-- ============================================
-- 8. INSERT SCHEDULE - NEED TO GET ROOM IDs DYNAMICALLY
-- ============================================
DECLARE
    v_auditorium_id NUMBER;
    v_mac1_id NUMBER;
    v_mcc9_id NUMBER;
    v_mtc16_id NUMBER;
    v_gym_id NUMBER;
BEGIN
    -- Get room IDs based on room names and buildings
    -- Adamjee Auditorium
    SELECT r.room_id INTO v_auditorium_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'AUDITORIUM' AND b.building_name = 'Adamjee';
    
    -- Adamjee MAC-1
    SELECT r.room_id INTO v_mac1_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'MAC-1' AND b.building_name = 'Adamjee';
    
    -- Aman CED MCC-9
    SELECT r.room_id INTO v_mcc9_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'MCC-9' AND b.building_name = 'Aman CED';
    
    -- Tabba MTC-16
    SELECT r.room_id INTO v_mtc16_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'MTC-16' AND b.building_name = 'Tabba';
    
    -- Sports Complex GYM
    SELECT r.room_id INTO v_gym_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'GYM' AND b.building_name = 'Sports Complex';
    
    DBMS_OUTPUT.PUT_LINE('Room IDs: Auditorium=' || v_auditorium_id || 
                        ', MAC-1=' || v_mac1_id || 
                        ', MCC-9=' || v_mcc9_id ||
                        ', MTC-16=' || v_mtc16_id ||
                        ', GYM=' || v_gym_id);
    
    -- Monday classes
    INSERT INTO Schedule (room_id, day_of_week, start_time, end_time, course_code) 
    VALUES (v_auditorium_id, 'MONDAY', TO_TIMESTAMP('1970-01-01 08:30:00', 'YYYY-MM-DD HH24:MI:SS'), 
            TO_TIMESTAMP('1970-01-01 09:45:00', 'YYYY-MM-DD HH24:MI:SS'), 'CS401');

    INSERT INTO Schedule (room_id, day_of_week, start_time, end_time, course_code) 
    VALUES (v_mac1_id, 'MONDAY', TO_TIMESTAMP('1970-01-01 10:00:00', 'YYYY-MM-DD HH24:MI:SS'), 
            TO_TIMESTAMP('1970-01-01 11:15:00', 'YYYY-MM-DD HH24:MI:SS'), 'MT301');

    -- Tuesday classes
    INSERT INTO Schedule (room_id, day_of_week, start_time, end_time, course_code) 
    VALUES (v_mcc9_id, 'TUESDAY', TO_TIMESTAMP('1970-01-01 08:30:00', 'YYYY-MM-DD HH24:MI:SS'), 
            TO_TIMESTAMP('1970-01-01 09:45:00', 'YYYY-MM-DD HH24:MI:SS'), 'FIN401');

    INSERT INTO Schedule (room_id, day_of_week, start_time, end_time, course_code) 
    VALUES (v_mtc16_id, 'TUESDAY', TO_TIMESTAMP('1970-01-01 10:00:00', 'YYYY-MM-DD HH24:MI:SS'), 
            TO_TIMESTAMP('1970-01-01 11:15:00', 'YYYY-MM-DD HH24:MI:SS'), 'MGT501');

    -- Wednesday classes
    INSERT INTO Schedule (room_id, day_of_week, start_time, end_time, course_code) 
    VALUES (v_auditorium_id, 'WEDNESDAY', TO_TIMESTAMP('1970-01-01 08:30:00', 'YYYY-MM-DD HH24:MI:SS'), 
            TO_TIMESTAMP('1970-01-01 09:45:00', 'YYYY-MM-DD HH24:MI:SS'), 'CS401');

    INSERT INTO Schedule (room_id, day_of_week, start_time, end_time, course_code) 
    VALUES (v_mac1_id, 'WEDNESDAY', TO_TIMESTAMP('1970-01-01 10:00:00', 'YYYY-MM-DD HH24:MI:SS'), 
            TO_TIMESTAMP('1970-01-01 11:15:00', 'YYYY-MM-DD HH24:MI:SS'), 'MT301');

    -- Thursday classes
    INSERT INTO Schedule (room_id, day_of_week, start_time, end_time, course_code) 
    VALUES (v_mcc9_id, 'THURSDAY', TO_TIMESTAMP('1970-01-01 08:30:00', 'YYYY-MM-DD HH24:MI:SS'), 
            TO_TIMESTAMP('1970-01-01 09:45:00', 'YYYY-MM-DD HH24:MI:SS'), 'FIN401');

    INSERT INTO Schedule (room_id, day_of_week, start_time, end_time, course_code) 
    VALUES (v_mtc16_id, 'THURSDAY', TO_TIMESTAMP('1970-01-01 10:00:00', 'YYYY-MM-DD HH24:MI:SS'), 
            TO_TIMESTAMP('1970-01-01 11:15:00', 'YYYY-MM-DD HH24:MI:SS'), 'MGT501');

    -- Friday classes
    INSERT INTO Schedule (room_id, day_of_week, start_time, end_time, course_code) 
    VALUES (v_gym_id, 'FRIDAY', TO_TIMESTAMP('1970-01-01 08:30:00', 'YYYY-MM-DD HH24:MI:SS'), 
            TO_TIMESTAMP('1970-01-01 09:45:00', 'YYYY-MM-DD HH24:MI:SS'), 'PE101');

    COMMIT;
    DBMS_OUTPUT.PUT_LINE('Schedule data inserted.');
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: Could not find one or more rooms.');
        ROLLBACK;
        RAISE;
END;
/

-- ============================================
-- 9. INSERT SAMPLE BOOKINGS - UPDATED TO GET ROOM IDs DYNAMICALLY
-- ============================================
DECLARE
    v_today DATE := TRUNC(SYSDATE);
    v_next_monday DATE;
    v_next_tuesday DATE;
    v_next_wednesday DATE;
    v_next_thursday DATE;
    v_next_friday DATE;
    
    v_breakout1_id NUMBER;
    v_mc_breakout1_id NUMBER;
    v_mt_breakout1_id NUMBER;
    v_auditorium_id NUMBER;
    v_event_hall_id NUMBER;
    v_breakout2_id NUMBER;
    v_mc_breakout2_id NUMBER;
BEGIN
    -- Calculate next week's dates
    v_next_monday := v_today + MOD(8 - TO_CHAR(v_today, 'D'), 7); -- Next Monday
    v_next_tuesday := v_next_monday + 1;
    v_next_wednesday := v_next_monday + 2;
    v_next_thursday := v_next_monday + 3;
    v_next_friday := v_next_monday + 4;
    
    -- Get room IDs dynamically
    -- Adamjee BREAKOUT-1
    SELECT r.room_id INTO v_breakout1_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'BREAKOUT-1' AND b.building_name = 'Adamjee';
    
    -- Aman CED MC-BREAKOUT-1
    SELECT r.room_id INTO v_mc_breakout1_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'MC-BREAKOUT-1' AND b.building_name = 'Aman CED';
    
    -- Tabba MT-BREAKOUT-1
    SELECT r.room_id INTO v_mt_breakout1_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'MT-BREAKOUT-1' AND b.building_name = 'Tabba';
    
    -- Adamjee AUDITORIUM
    SELECT r.room_id INTO v_auditorium_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'AUDITORIUM' AND b.building_name = 'Adamjee';
    
    -- Adamjee EVENT HALL
    SELECT r.room_id INTO v_event_hall_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'EVENT HALL' AND b.building_name = 'Adamjee';
    
    -- Adamjee BREAKOUT-2
    SELECT r.room_id INTO v_breakout2_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'BREAKOUT-2' AND b.building_name = 'Adamjee';
    
    -- Aman CED MC-BREAKOUT-2
    SELECT r.room_id INTO v_mc_breakout2_id 
    FROM Room r 
    JOIN Building b ON r.building_id = b.building_id
    WHERE r.room_name = 'MC-BREAKOUT-2' AND b.building_name = 'Aman CED';
    
    DBMS_OUTPUT.PUT_LINE('Room IDs: BREAKOUT-1=' || v_breakout1_id || 
                        ', MC-BREAKOUT-1=' || v_mc_breakout1_id ||
                        ', MT-BREAKOUT-1=' || v_mt_breakout1_id);
    
    -- Muskan's booking (next Monday 10:00 AM)
    INSERT INTO Booking (ERP, room_id, booking_date, start_time, end_time, purpose, status) 
    VALUES (10001, v_breakout1_id, v_next_monday,
            TO_TIMESTAMP(TO_CHAR(v_next_monday, 'YYYY-MM-DD') || ' 10:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            TO_TIMESTAMP(TO_CHAR(v_next_monday, 'YYYY-MM-DD') || ' 11:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            'Group study session for CS401', 'Approved');
    
    -- Kashish's booking (next Tuesday 2:00 PM)
    INSERT INTO Booking (ERP, room_id, booking_date, start_time, end_time, purpose, status) 
    VALUES (10002, v_mc_breakout1_id, v_next_tuesday,
            TO_TIMESTAMP(TO_CHAR(v_next_tuesday, 'YYYY-MM-DD') || ' 14:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            TO_TIMESTAMP(TO_CHAR(v_next_tuesday, 'YYYY-MM-DD') || ' 15:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            'Project meeting with team', 'Approved');
    
    -- Mustafa's booking (next Wednesday 9:00 AM)
    INSERT INTO Booking (ERP, room_id, booking_date, start_time, end_time, purpose, status) 
    VALUES (10003, v_mt_breakout1_id, v_next_wednesday,
            TO_TIMESTAMP(TO_CHAR(v_next_wednesday, 'YYYY-MM-DD') || ' 09:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            TO_TIMESTAMP(TO_CHAR(v_next_wednesday, 'YYYY-MM-DD') || ' 10:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            'Presentation practice', 'Approved');
    
    -- Hiba's booking (next Thursday 1:00 PM)
    INSERT INTO Booking (ERP, room_id, booking_date, start_time, end_time, purpose, status) 
    VALUES (10004, v_auditorium_id, v_next_thursday,
            TO_TIMESTAMP(TO_CHAR(v_next_thursday, 'YYYY-MM-DD') || ' 13:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            TO_TIMESTAMP(TO_CHAR(v_next_thursday, 'YYYY-MM-DD') || ' 14:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            'Research discussion', 'Approved');
    
    -- Abdullah's booking (next Friday 11:00 AM)
    INSERT INTO Booking (ERP, room_id, booking_date, start_time, end_time, purpose, status) 
    VALUES (10005, v_event_hall_id, v_next_friday,
            TO_TIMESTAMP(TO_CHAR(v_next_friday, 'YYYY-MM-DD') || ' 11:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            TO_TIMESTAMP(TO_CHAR(v_next_friday, 'YYYY-MM-DD') || ' 12:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            'Study group for Economics', 'Approved');
    
    -- Add a cancelled booking
    INSERT INTO Booking (ERP, room_id, booking_date, start_time, end_time, purpose, status) 
    VALUES (10002, v_breakout2_id, v_next_monday + 7,
            TO_TIMESTAMP(TO_CHAR(v_next_monday + 7, 'YYYY-MM-DD') || ' 10:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            TO_TIMESTAMP(TO_CHAR(v_next_monday + 7, 'YYYY-MM-DD') || ' 11:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            'Cancelled meeting', 'Cancelled');
    
    -- Add a rejected booking
    INSERT INTO Booking (ERP, room_id, booking_date, start_time, end_time, purpose, status) 
    VALUES (10003, v_mc_breakout2_id, v_next_tuesday + 7,
            TO_TIMESTAMP(TO_CHAR(v_next_tuesday + 7, 'YYYY-MM-DD') || ' 14:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            TO_TIMESTAMP(TO_CHAR(v_next_tuesday + 7, 'YYYY-MM-DD') || ' 15:00:00', 'YYYY-MM-DD HH24:MI:SS'),
            'Rejected by admin', 'Rejected');
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('8 bookings inserted with future dates.');
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: Could not find one or more rooms for bookings.');
        ROLLBACK;
        RAISE;
END;
/

-- Continue with the rest of your script (Announcements, Pending Registrations, etc.)
-- ============================================
-- 10. INSERT ANNOUNCEMENTS
-- ============================================
INSERT INTO Announcement (ERP, title, description, date_posted) 
VALUES (30003, 'Adamjee Building Maintenance', 
        'Please note that Adamjee building will undergo maintenance this Saturday. All rooms will be unavailable from 8 AM to 5 PM.',
        SYSTIMESTAMP);

INSERT INTO Announcement (ERP, title, description, date_posted) 
VALUES (30002, 'New Breakout Rooms Available', 
        'Two new breakout rooms (MC-BREAKOUT-1 and MC-BREAKOUT-2) are now available for booking in Aman CED building.',
        SYSTIMESTAMP - INTERVAL '1' DAY);

INSERT INTO Announcement (ERP, title, description, date_posted) 
VALUES (30001, 'Lab Equipment Upgrade', 
        'The computer labs in Tabba building will be upgraded with new equipment next week. Some labs may be temporarily unavailable.',
        SYSTIMESTAMP - INTERVAL '2' DAY);

INSERT INTO Announcement (ERP, title, description, date_posted) 
VALUES (30005, 'Executive Center Renovation', 
        'Executive Center will be partially closed for renovation next week. Please plan your bookings accordingly.',
        SYSTIMESTAMP - INTERVAL '3' DAY);

INSERT INTO Announcement (ERP, title, description, date_posted) 
VALUES (30004, 'Sports Complex Schedule Change', 
        'Due to sports events, the Sports Complex will have limited availability from tomorrow for one week.',
        SYSTIMESTAMP - INTERVAL '4' DAY);

COMMIT;

select * from user_table;

-- 2.1 All users with roles
SELECT ERP, name, email, role, phone_number, LENGTH(user_password) as password_length
FROM User_Table
ORDER BY role, ERP;

-- 2.2 Student users only
SELECT u.ERP, u.name, u.email, s.program, s.intake_year, u.phone_number
FROM User_Table u
JOIN Student s ON u.ERP = s.ERP
ORDER BY u.ERP;
-- 2.3 Admin users (PO and BI)
SELECT u.ERP, u.name, u.email, u.role, u.phone_number
FROM User_Table u
WHERE u.role IN ('ProgramOffice', 'BuildingIncharge')
ORDER BY u.role, u.ERP;

-- 3.1 All buildings
SELECT building_id, building_name
FROM Building
ORDER BY building_id;

-- 3.2 Rooms per building with types
SELECT b.building_name, r.room_id, r.room_name, r.room_type
FROM Room r
JOIN Building b ON r.building_id = b.building_id
ORDER BY b.building_name, r.room_type, r.room_name;

-- 3.3 Count of rooms by building and type
SELECT b.building_name, 
       r.room_type,
       COUNT(*) as room_count
FROM Room r
JOIN Building b ON r.building_id = b.building_id
GROUP BY b.building_name, r.room_type
ORDER BY b.building_name, r.room_type;

-- 4.1 Building incharges with building names
SELECT i.incharge_id, u.name as incharge_name, u.email, b.building_name
FROM Incharge i
JOIN User_Table u ON i.incharge_id = u.ERP
JOIN Building b ON i.building_id = b.building_id
ORDER BY b.building_name;

-- 4.2 Buildings without incharges (should be none)
SELECT b.building_id, b.building_name
FROM Building b
LEFT JOIN Incharge i ON b.building_id = i.building_id
WHERE i.incharge_id IS NULL
ORDER BY b.building_id;

-- 5.1 All schedule entries
SELECT s.schedule_id, b.building_name, r.room_name, 
       s.day_of_week, 
       TO_CHAR(s.start_time, 'HH24:MI') as start_time,
       TO_CHAR(s.end_time, 'HH24:MI') as end_time,
       s.course_code
FROM Schedule s
JOIN Room r ON s.room_id = r.room_id
JOIN Building b ON r.building_id = b.building_id
ORDER BY s.day_of_week, s.start_time;

-- 5.2 Schedule by day of week
SELECT day_of_week, COUNT(*) as class_count
FROM Schedule
GROUP BY day_of_week
ORDER BY 
    CASE day_of_week
        WHEN 'MONDAY' THEN 1
        WHEN 'TUESDAY' THEN 2
        WHEN 'WEDNESDAY' THEN 3
        WHEN 'THURSDAY' THEN 4
        WHEN 'FRIDAY' THEN 5
        WHEN 'SATURDAY' THEN 6
        ELSE 7
    END;

-- 6.1 All bookings with details
SELECT b.booking_id, u.name as student_name, u.ERP,
       bld.building_name, r.room_name, r.room_type,
       b.booking_date,
       TO_CHAR(b.start_time, 'YYYY-MM-DD HH24:MI') as start_datetime,
       TO_CHAR(b.end_time, 'YYYY-MM-DD HH24:MI') as end_datetime,
       b.purpose, b.status, b.created_date
FROM Booking b
JOIN User_Table u ON b.ERP = u.ERP
JOIN Room r ON b.room_id = r.room_id
JOIN Building bld ON r.building_id = bld.building_id
ORDER BY b.booking_date DESC, b.start_time DESC;

-- 6.2 Bookings by status
SELECT status, COUNT(*) as booking_count
FROM Booking
GROUP BY status
ORDER BY status;

-- 6.3 Bookings by student
SELECT u.ERP, u.name, COUNT(*) as total_bookings,
       SUM(CASE WHEN b.status = 'Approved' THEN 1 ELSE 0 END) as approved,
       SUM(CASE WHEN b.status = 'Cancelled' THEN 1 ELSE 0 END) as cancelled,
       SUM(CASE WHEN b.status = 'Rejected' THEN 1 ELSE 0 END) as rejected
FROM Booking b
JOIN User_Table u ON b.ERP = u.ERP
GROUP BY u.ERP, u.name
ORDER BY u.ERP;

-- 6.4 Upcoming bookings (future dates only)
SELECT b.booking_id, u.name as student, bld.building_name, r.room_name,
       b.booking_date,
       TO_CHAR(b.start_time, 'HH24:MI') as start_time,
       TO_CHAR(b.end_time, 'HH24:MI') as end_time,
       b.purpose, b.status
FROM Booking b
JOIN User_Table u ON b.ERP = u.ERP
JOIN Room r ON b.room_id = r.room_id
JOIN Building bld ON r.building_id = bld.building_id
WHERE b.booking_date >= TRUNC(SYSDATE)
ORDER BY b.booking_date, b.start_time;

-- 7.1 All announcements with details
SELECT a.announcement_id, u.name as posted_by, b.building_name,
       a.title, a.description,
       TO_CHAR(a.date_posted, 'DD-MON-YYYY HH24:MI') as posted_date,
       TO_CHAR(a.created_date, 'DD-MON-YYYY HH24:MI') as created_date
FROM Announcement a
JOIN User_Table u ON a.ERP = u.ERP
LEFT JOIN Incharge i ON a.ERP = i.incharge_id
LEFT JOIN Building b ON i.building_id = b.building_id
ORDER BY a.date_posted DESC;

-- 7.2 Announcements by building incharge
SELECT u.name as incharge_name, b.building_name, COUNT(*) as announcement_count
FROM Announcement a
JOIN User_Table u ON a.ERP = u.ERP
JOIN Incharge i ON a.ERP = i.incharge_id
JOIN Building b ON i.building_id = b.building_id
GROUP BY u.name, b.building_name
ORDER BY b.building_name;

-- 8.1 All pending registrations
SELECT email, erp, name, role, phone_number, 
       verification_code,
       TO_CHAR(code_expiry, 'DD-MON-YYYY HH24:MI:SS') as expiry_time
FROM PendingRegistration
ORDER BY code_expiry;

-- 8.2 Check if any pending registrations are expired
SELECT email, name, 
       TO_CHAR(code_expiry, 'DD-MON-YYYY HH24:MI:SS') as expiry_time,
       CASE 
           WHEN code_expiry < SYSTIMESTAMP THEN 'EXPIRED'
           ELSE 'ACTIVE'
       END as status
FROM PendingRegistration
ORDER BY code_expiry;

-- 9.1 Students without corresponding User_Table entry (should be 0)
SELECT s.ERP, s.program, s.intake_year
FROM Student s
LEFT JOIN User_Table u ON s.ERP = u.ERP
WHERE u.ERP IS NULL;

-- 9.2 Bookings for non-existent users (should be 0)
SELECT b.booking_id, b.ERP
FROM Booking b
LEFT JOIN User_Table u ON b.ERP = u.ERP
WHERE u.ERP IS NULL;

-- 9.3 Bookings for non-existent rooms (should be 0)
SELECT b.booking_id, b.room_id
FROM Booking b
LEFT JOIN Room r ON b.room_id = r.room_id
WHERE r.room_id IS NULL;

-- 9.4 Schedule for non-existent rooms (should be 0)
SELECT s.schedule_id, s.room_id
FROM Schedule s
LEFT JOIN Room r ON s.room_id = r.room_id
WHERE r.room_id IS NULL;

-- 1. What's actually in your Announcement table RIGHT NOW?
SELECT announcement_id, ERP, title, description, date_posted 
FROM Announcement 
ORDER BY announcement_id;

-- 2. Do these ERPs exist in User_Table?
SELECT ERP, name, role 
FROM User_Table 
WHERE ERP IN (30001, 30002, 30003, 30004, 30005);

-- 3. Are these ERPs in the Incharge table?
SELECT incharge_id, building_id 
FROM Incharge 
WHERE incharge_id IN (30001, 30002, 30003, 30004, 30005);

-- 4. What does your procedure ACTUALLY return?
-- Run this PL/SQL block:
SET SERVEROUTPUT ON;
DECLARE
    v_cursor SYS_REFCURSOR;
    v_id NUMBER;
    v_title VARCHAR2(100);
    v_desc VARCHAR2(300);
    v_date TIMESTAMP;
    v_name VARCHAR2(100);
    v_building VARCHAR2(50);
    v_count NUMBER := 0;
BEGIN
    ShowAllAnnouncements(v_cursor);
    
    LOOP
        FETCH v_cursor INTO v_id, v_title, v_desc, v_date, v_name, v_building;
        EXIT WHEN v_cursor%NOTFOUND;
        
        v_count := v_count + 1;
        DBMS_OUTPUT.PUT_LINE('Row ' || v_count || ':');
        DBMS_OUTPUT.PUT_LINE('  ID: ' || v_id);
        DBMS_OUTPUT.PUT_LINE('  Title: ' || v_title);
        DBMS_OUTPUT.PUT_LINE('  Posted by: ' || v_name);
        DBMS_OUTPUT.PUT_LINE('  Building: ' || v_building);
        DBMS_OUTPUT.PUT_LINE('  Date: ' || TO_CHAR(v_date, 'DD-MON-YYYY HH24:MI'));
    END LOOP;
    
    CLOSE v_cursor;
    
    IF v_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE(' Procedure returned NO ROWS!');
    ELSE
        DBMS_OUTPUT.PUT_LINE(' Procedure returned ' || v_count || ' rows');
    END IF;
END;
/

select * from user_table;


CREATE OR REPLACE PROCEDURE ViewAllRooms(
    p_result OUT SYS_REFCURSOR
)
AS
BEGIN
    /*
    PURPOSE: View all rooms in the university
    OUTPUT: All rooms with building information
    USAGE: For general room viewing/location finding
    */
    
    OPEN p_result FOR
        SELECT 
            r.room_id,
            r.room_name,
            r.room_type,
            b.building_id,
            b.building_name
        FROM Room r
        JOIN Building b ON r.building_id = b.building_id
        ORDER BY b.building_name, r.room_type, r.room_name;
    
END ViewAllRooms;
/

CREATE OR REPLACE PROCEDURE GetRoomsByBuilding(
    p_building_name IN Building.building_name%TYPE,
    p_result        OUT SYS_REFCURSOR
)
AS
    v_building_exists NUMBER;
BEGIN
    /*
    PURPOSE: Get all rooms in a specific building
    INPUT: Building name
    OUTPUT: All rooms in that building
    EXAMPLE: EXEC GetRoomsByBuilding('Adamjee', :cursor);
    */
    
    -- Check if building exists
    SELECT COUNT(*) INTO v_building_exists
    FROM Building
    WHERE UPPER(building_name) = UPPER(p_building_name);
    
    IF v_building_exists = 0 THEN
        -- Return empty cursor if building doesn't exist
        OPEN p_result FOR
            SELECT 
                r.room_id,
                r.room_name,
                r.room_type,
                b.building_id,
                b.building_name
            FROM Room r
            JOIN Building b ON r.building_id = b.building_id
            WHERE 1 = 0; -- Always false
        RETURN;
    END IF;
    
    -- Get all rooms in the specified building
    OPEN p_result FOR
        SELECT 
            r.room_id,
            r.room_name,
            r.room_type,
            b.building_id,
            b.building_name
        FROM Room r
        JOIN Building b ON r.building_id = b.building_id
        WHERE UPPER(b.building_name) = UPPER(p_building_name)
        ORDER BY r.room_type, r.room_name;
    
END GetRoomsByBuilding;
/

CREATE OR REPLACE PROCEDURE SearchRoomsByName(
    p_search_term IN VARCHAR2,
    p_result      OUT SYS_REFCURSOR
)
AS
BEGIN
    /*
    PURPOSE: Search rooms by room name (partial match)
    INPUT: Search term to match in room names
    OUTPUT: All rooms where room_name contains the search term
    EXAMPLE: 
        EXEC SearchRoomsByName('MAC', :cursor); -- Finds MAC-1, MAC-2, etc.
        EXEC SearchRoomsByName('AUDITORIUM', :cursor);
    */
    
    IF p_search_term IS NULL OR LENGTH(TRIM(p_search_term)) = 0 THEN
        -- If search term is empty, return all rooms
        OPEN p_result FOR
            SELECT 
                r.room_id,
                r.room_name,
                r.room_type,
                b.building_id,
                b.building_name
            FROM Room r
            JOIN Building b ON r.building_id = b.building_id
            ORDER BY b.building_name, r.room_name;
    ELSE
        -- Search for rooms with partial match in room_name
        OPEN p_result FOR
            SELECT 
                r.room_id,
                r.room_name,
                r.room_type,
                b.building_id,
                b.building_name
            FROM Room r
            JOIN Building b ON r.building_id = b.building_id
            WHERE UPPER(r.room_name) LIKE '%' || UPPER(TRIM(p_search_term)) || '%'
            ORDER BY b.building_name, r.room_name;
    END IF;
    
END SearchRoomsByName;
/

INSERT INTO Announcement (ERP, title, description, date_posted) 
VALUES (30002, 'Hi and Bye', 
        'I am so sleepy',
        SYSTIMESTAMP - INTERVAL '1' DAY);

commit;

select * from announcement;
